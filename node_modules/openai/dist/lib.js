import { ContentLabel, } from './types.js';
import { Transform } from 'stream';
import FormData from 'form-data';
import fetch from 'node-fetch';
const baseUrl = 'https://api.openai.com';
const defaultVersion = 'v1';
export class OpenAI {
    constructor(apiKey, organizationId, version = defaultVersion) {
        this.headers = {
            'authorization': `Bearer ${apiKey}`,
            'content-type': 'application/json',
        };
        if (organizationId) {
            this.headers['openai-organization'] = organizationId;
        }
        this.url = `${baseUrl}/${version}`;
    }
    getEngines() {
        return this.request('/engines', 'GET').then((r) => r.data);
    }
    getEngine(engine) {
        return this.request(`/engines/${engine}`, 'GET');
    }
    complete(engine, options) {
        return this.request(`/engines/${engine}/completions`, 'POST', options);
    }
    completeFromModel(fineTunedModel, options) {
        return this.request(`/completions`, 'POST', { ...options, model: fineTunedModel });
    }
    async completeAndStream(engine, options) {
        const request = await this.requestRaw(`/engines/${engine}/completions`, 'POST', { ...options, stream: true });
        return request.body.pipe(this.eventStreamTransformer());
    }
    async completeFromModelAndStream(fineTunedModel, options) {
        const request = await this.requestRaw(`/completions`, 'POST', {
            ...options,
            model: fineTunedModel,
            stream: true,
        });
        return request.body.pipe(this.eventStreamTransformer());
    }
    async contentFilter(content, user) {
        const completion = await this.complete('content-filter-alpha-c4', {
            prompt: `<|endoftext|>${content}\n--\nLabel:`,
            temperature: 0,
            max_tokens: 1,
            top_p: 1,
            frequency_penalty: 0,
            presence_penalty: 0,
            logprobs: 10,
            user,
        });
        let label = Number(completion.choices[0].text);
        if (label === ContentLabel.Unsafe) {
            const logprobs = completion.choices[0].logprobs?.top_logprobs[0];
            if (logprobs && logprobs['2'] < -0.355) {
                if (logprobs['0'] && logprobs['1']) {
                    label = logprobs['0'] >= logprobs['1'] ? ContentLabel.Safe : ContentLabel.Sensitive;
                }
                else if (logprobs['0']) {
                    label = ContentLabel.Safe;
                }
                else if (logprobs['1']) {
                    label = ContentLabel.Sensitive;
                }
            }
        }
        if (![0, 1, 2].includes(label)) {
            label = ContentLabel.Unsafe;
        }
        return label;
    }
    search(engine, options) {
        return this.request(`/engines/${engine}/search`, 'POST', options).then((r) => r.data);
    }
    classify(options) {
        return this.request('/classifications', 'POST', options);
    }
    answer(options) {
        return this.request('/answers', 'POST', options);
    }
    getFiles() {
        return this.request('/files', 'GET').then((r) => r.data);
    }
    uploadFile(file, jsonlines, purpose) {
        const data = new FormData();
        let fileJsonlines;
        if (Array.isArray(jsonlines)) {
            if (typeof jsonlines[0] === 'object') {
                jsonlines = jsonlines.map((j) => JSON.stringify(j));
            }
            fileJsonlines = jsonlines.join('\n');
        }
        else {
            fileJsonlines = jsonlines;
        }
        data.append('file', fileJsonlines, file);
        data.append('purpose', purpose);
        return this.request('/files', 'POST', data);
    }
    getFile(fileId) {
        return this.request(`/files/${fileId}`, 'GET');
    }
    deleteFile(fileId) {
        return this.request(`/files/${fileId}`, 'DELETE');
    }
    finetune(options) {
        return this.request(`/fine-tunes`, 'POST', options);
    }
    getFinetunes() {
        return this.request('/fine-tunes', 'GET').then((r) => r.data);
    }
    getFinetune(finetuneId) {
        return this.request(`/fine-tunes/${finetuneId}`, 'GET');
    }
    cancelFinetune(finetuneId) {
        return this.request(`/fine-tunes/${finetuneId}/cancel`, 'POST');
    }
    getFinetuneEvents(finetuneId) {
        return this.request(`/fine-tunes/${finetuneId}/events`, 'GET').then((r) => r.data);
    }
    createEmbedding(engine, options) {
        return this.request(`/engines/${engine}/embeddings`, 'POST', options);
    }
    async requestRaw(path, method, body) {
        let headers = { ...this.headers };
        if (body instanceof FormData) {
            delete headers['content-type'];
            headers = body.getHeaders(headers);
        }
        else if (!['string', 'undefined'].includes(typeof body)) {
            body = JSON.stringify(body);
        }
        const response = await fetch(this.url + path, {
            headers,
            method,
            body: body,
        });
        if (!response.ok) {
            let errorBody;
            try {
                const { error: { message }, } = (await response.json());
                errorBody = message;
            }
            catch {
                try {
                    errorBody = await response.text();
                }
                catch {
                    errorBody = 'Failed to get body as text';
                }
            }
            throw new Error(`OpenAI did not return ok: ${response.status} ~ Error body: ${errorBody}`);
        }
        return response;
    }
    async request(path, method, body) {
        const response = await this.requestRaw(path, method, body);
        return response.json();
    }
    eventStreamTransformer() {
        const dataHeader = Buffer.from('data: ');
        return new Transform({
            transform: function (chunk, _, callback) {
                if (chunk.length >= dataHeader.length &&
                    dataHeader.compare(chunk, undefined, dataHeader.length) === 0) {
                    if (this.prevChunk) {
                        const completion = JSON.parse(this.prevChunk.toString());
                        this.push(completion.choices[0].text);
                        this.prevChunk = undefined;
                    }
                    chunk = chunk.slice(dataHeader.length);
                }
                this.prevChunk = this.prevChunk ? Buffer.concat([this.prevChunk, chunk]) : chunk;
                callback();
            },
        });
    }
}
